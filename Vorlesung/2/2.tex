\chapter{Vorlesung 2}
\section*{Heapsort (Fortsetzung)}
%Grafik
\subsection{Pseudocode}
\begin{lstlisting}
heapify ( int[] a, int i, int n) {
  while (2i + 1 < n) {		//linkes Kind von i existiert
    int j = 2i + 1;
    if ( 2i +2 < n)  		//rechtes Kind von i existiert
      if ( a[j] < a[j+1])
        j = j + 1;  		//j steht für Indes des größten Kindes
    if ( a[i] > a[j])  		//Vater größer als Kind
      break;  			//Abbruch, weil heap bereits erfüllt
    swap(a,i,j); 		//Tausch zwischen Vater und Kind
    i = j;
  }
}
\end{lstlisting}
\subsubsection{1. Phase: Bottom-up Strategie zum Heapaufbau}
\begin{lstlisting}
for ( int i = n/2; i >= 0; i--)
  heapify(a,i,n);
\end{lstlisting}
\subsubsection{2. Phase: Sortierphase}
\begin{lstlisting}
for ( int i = n-1; i >= 0; i--) {
  swap(a,0,i);
  heapify(a,0,i);
}
\end{lstlisting}
\subsection{Korrektheitsbetrachtung}
\begin{description}
	\item[Invariante beim Heapaufbau:] Beim Durchlauf der for-Schleife wird die Heapeigenschaft vom unteren Baumlevel bis zur Wurzel hergestellt.
	\item[Invariante für Sortierphase:] Nach jedem weiteren Durchlauf der for-Schleife findet ein weiteres Element am Feldende seinen "`richtigen Platz"'.
\end{description}
\subsection{Laufzeitanalyse}
$T(n)=$ Zahl der Elementvergleiche.
\subsubsection{Analyse Heapaufbau:}
\[  \]%Fortsetzung folgt