\documentclass[a4paper,11pt,twoside]{scrartcl}
\input{../../head/package}
\input{../../head/listing}
\input{../../head/format}

\title{Datenstrukturen und effiziente Algorithmen\\ Blatt 10}
\author{Markus Vieth, David Klopp, Christian Stricker}
\date{\today}



\begin{document}

\maketitle
\cleardoublepage
\pagestyle{myheadings}
\markboth{Markus Vieth,  David Klopp, Christian Stricker}{Markus Vieth, David Klopp, Christian Stricker}

\section*{Aufgabe 1}

Die Breitensuche kann das Single-Source-Shortest-Path-Problem schneller lösen. Die Breitensuche hat eine Laufzeit von O(|V|+|E|), wogegen der Dijkstra-Algorithmus eine Laufzeit von O(|V | log |V | + |E|) hat. Dies kommt durch die Suche des kleinsten Elements in der Warteschlange/Einsortieren des nächsten gefundenen Knotens in die Warteschlange. Die Breitensuche nimmt immer das nächste Element aus der Warteschlange und spart dadurch die Zeit zum Suchen. Sowohl die Breitensuche als auch der Dijkstra-Algorithmus findet immer die kürzesten Wege von einem Startknoten aus.
Wenn man den kürzesten Weg mithilfe der Tiefensuche sucht, findet man meistens schneller eine Lösung. Da die Tiefensuche nach einem gefundenen Weg abbricht, ist dieser Weg mit einer großen Wahrscheinlich nicht der kürzester Weg. Je größer der Graph und je mehr Wege es gibt, desto unwahrscheinlicher ist es, dass die Tiefensuche die korrekte Lösung für das Problem findet. (Einzige Ausnahme ist, es gibt nur einen Weg und somit ist dies der kürzester Weg. Dies ist aber nur ein Spezialfall, der selten vorkommt.) 

\newpage
 
\section*{Aufgabe 2}
\subsection*{a)}
\vspace*{-50pt}
\begin{figure}[H]
	\centering
	\includegraphics*[scale=0.65]{Bilder/2a_Dijkstra}
\end{figure}
Legende:
\begin{description}
	\item[Blau] Knoten in der Warteschlange
	\item[Gelb] Der derzeitige ausgewählte Knoten
	\item[Grün] Abgearbeiteter Knoten
\end{description}
\subsection*{b)} 
\begin{figure}[H]
	\centering
	\includegraphics*[scale=0.68]{Bilder/2b_Prim}
\end{figure}
\vspace{-30pt}
Legende:
\begin{description}
	\item[Blau] Potenzielle Kante
	\item[Gelb] Besuchte Knoten
	\item[Grün] Gewählte Kante
\end{description}
Spannbaum siehe d)
\subsection*{c)}
Der Prim-Algorithmus sucht eine Vernetzung aller Knoten, sodass die Gesamtlänge des Netzes minimal wird. Der Startpunkt ist bei diesem Algorithmus egal, er kommt immer zu dem selben Ergebnis. Dies ist z.B. beim Aufstellen von Strommasten nützlich, um die Kosten zu minimieren und trotzdem alle Orte mit Strom zu versorgen.
Der Dijkstra-Algorithmus hingegen sucht den kürzesten Weg von einem bestimmten Startknoten aus zu allen anderen Knoten. Hilfreich ist dies z.B. Bei Onlineversandhändlern. Diese haben ein lokales Lager (bestimmten Startknoten) und suchen den kürzesten Weg zu ggf. allen anderen Orten (Knoten). Ein \glqq langer Weg\grqq ~über die Autobahn ist meist schneller als durch viele eng zusammen liegende Orte zu fahren. Deshalb ist die Gesamtlänge der Strecke im Spannbaum meist länger als beim Prim-Algorithmus.

\subsection*{d)}
Siehe Teilaufgabe c)
\begin{figure}[H]
	\centering
	\includegraphics*[scale=0.75]{Bilder/2c_Unterschied}
\end{figure}

\clearpage
\vspace*{-50pt}
\section*{Aufgabe 3}
\subsection*{UnionFind.java}
\lstinputlisting[style=java,basicstyle=\small\ttfamily]{Code/Matrix/app/UnionFind.java}
\pagebreak
\subsection*{SpanningTree.java}
\lstinputlisting[style=java,basicstyle=\small\ttfamily]{Code/Matrix/app/SpanningTree.java}

\end{document}