\documentclass[a4paper,11pt,twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{ngerman, eucal, mathrsfs, amsfonts, bbm, amsmath, amssymb, stmaryrd,graphicx, array, geometry, listings, xcolor}
\usepackage{graphicx}
\usepackage[official]{eurosym}
\DeclareUnicodeCharacter{20AC}{\EUR{}}
\geometry{left=25mm, right=15mm, bottom=25mm}
\setlength{\parindent}{0em} 
\setlength{\headheight}{0em} 
\title{Datenstrukturen und effiziente Algorithmen\\ Blatt 10}
\author{Markus Vieth, David Klopp, Christian Stricker}
\date{\today}


\definecolor{middlegray}{rgb}{0.5,0.5,0.5}
\definecolor{lightgray}{rgb}{0.8,0.8,0.8}
\definecolor{orange}{rgb}{0.8,0.3,0.3}
\definecolor{yac}{rgb}{0.6,0.6,0.1}
\definecolor{green}{rgb}{0,.5,0}

\lstdefinestyle{c}{
	keywordstyle=\bfseries\ttfamily\color{blue},
	stringstyle=\color{orange}\ttfamily,
	commentstyle=\color{green}\ttfamily,
	emph={@Override, while, forall, if}, 
	emphstyle=\color{green}\texttt,
	emph={[2]List, Queue},
	emphstyle={[2]\color{yac}\texttt},
	}
\lstset{
	basicstyle=\ttfamily,
	showstringspaces=false,
	flexiblecolumns=true,
	tabsize=2,
	numbers=left,
	numberstyle=\tiny,
	numberblanklines=false,
	stepnumber=1,
	numbersep=10pt,
	xleftmargin=15pt,
	breaklines=true,
	inputencoding=utf8
}

\lstdefinestyle{java}{
	emph={@Override}, 
	emphstyle=\color{teal}\texttt,
	emph={[2]Node,T,Comparable,AbstractNode,System, Thread,Random, Tree, Integer, Math, String, InterruptedException, Map, Entry, Point, TreeMap, PrintWriter, Scanner, FileReader, FileInputStream, FileNotFoundException, InputStreamReader, UnsupportedEncodingException, DecimalFormat, ArrayList, HashSet, LinkedList, IOException, HashMap, MapTest, MyHashMap, Puzzle, MyQueue, StringBuilder, NoSuchElementException, List, Queue, Vector, Tuple,Search, IllegalArgumentException},
	emphstyle={[2]\color{yac}\texttt},
	texcl=true,
	keywordstyle=\color{blue}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{green}\ttfamily
	}

\lstset{literate=
	{á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
	{Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
	{à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
	{À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
	{ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
	{Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
	{â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
	{Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
	{œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
	{ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
	{ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
	{€}{{\EUR}}1 {£}{{\pounds}}1
}

\begin{document}

\maketitle
\cleardoublepage
\pagestyle{myheadings}
\markboth{Markus Vieth,  David Klopp, Christian Stricker}{Markus Vieth, David Klopp, Christian Stricker}

\section*{Aufgabe 1}

Die Breitensuche kann das Single-Source-Shortest-Path-Problem schneller lösen. Die Breitensuche hat eine Laufzeit von O(|V|+|E|), wogegen der Dijkstra-Algorithmus eine Laufzeit von O(|V | log |V | + |E|) hat. Dies kommt durch die Suche des kleinsten Elements in der Warteschlange/Einsortieren des nächsten gefundenen Knotens in die Warteschlange. Die Breitensuche nimmt immer das nächste Element aus der Warteschlange und spart dadurch die Zeit zum Suchen. Sowohl die Breitensuche als auch der Dijkstra-Algorithmus findet immer die kürzesten Wege von einem Startknoten aus.
Wenn man den kürzesten Weg mithilfe der Tiefensuche sucht, findet man meistens schneller eine Lösung. Da die Tiefensuche nach einem gefundenen Weg abbricht, ist dieser Weg mit einer großen Wahrscheinlich nicht der kürzester Weg. Je größer der Graph und je mehr Wege es gibt, desto unwahrscheinlicher ist es, das die Tiefensuche die korrekte Lösung für das Problem löst. (Einzige Ausnahme ist, es gibt nur einen Weg und somit ist dies der kürzester Weg. Dies ist aber nur ein spezial -Fall, der selten vorkommt.) 


\section*{Aufgabe 2}
\subsection*{a)}
\includegraphics*[scale=0.8]{Bilder/2a_Dijkstra.png}\\
Legende:\\
- Blau : Knoten in der Warteschlange\\
- Gelb : Der derzeitige ausgewählte Knoten\\
- Grün : Abgearbeiteter Knoten\\
\subsection*{c)} 
\includegraphics*[scale=1]{Bilder/2b_Prim.png}\\
Legende:\\
- Gelb : Besuchte Knoten\\
- Grün : Gewählte Kante\\
- Blau : Potenzielle Kante\\
\\
Der Prim-Algorithmus sucht eine Vernetzung aller Knoten, sodass die Gesamtlänge des Netzes minimal wird. Der Startpunkt ist bei diesem Algorithmus egal, es kommt immer zu dem selben Ergebnis. Dies ist z.B. nützlich beim Aufstellen von Strommasten, um die Kosten zu minimieren, trotzdem alle Orte mit Strom zu versorgen.
Der Dijkstra-Algorithmus hingegen sucht den kürzesten Weg von einem bestimmten Startknoten aus zu allen anderen Knoten. Hilfreich ist dies z.B. Bei Onlineversandhändler. Diese haben ein lokales Lager(bestimmten Startknoten) und suchen den kürzesten Weg zu ggf allen anderen Orten(Knoten). Ein \glqq langer Weg\grqq ~über die Autobahn ist meist schneller als durch viele enge, zusammen liegenden Orten zu fahren. Deshalb ist die Gesamtlänge der Strecke im Spannbaums meist länger als beim Prim-Algorithmus.

\subsection*{d)}
Siehe Teilaufgabe c)
\includegraphics*[scale=1]{Bilder/2c_Unterschied.png}


\section*{Aufgabe 3}

\end{document}