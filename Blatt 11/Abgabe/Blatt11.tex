\documentclass[a4paper,11pt,twoside]{scrartcl}
\input{../../head/package}
\input{../../head/listing}
\input{../../head/format}

\title{Datenstrukturen und effiziente Algorithmen\\ Blatt 11}
\author{Markus Vieth, David Klopp, Christian Stricker}
\date{\today}



\begin{document}

\maketitle
\cleardoublepage
\pagestyle{myheadings}
\markboth{Markus Vieth,  David Klopp, Christian Stricker}{Markus Vieth, David Klopp, Christian Stricker}

\section*{Aufgabe 1}
\subsection*{Python-Code}
\lstinputlisting[style=python,basicstyle=\small\ttfamily]{Code/wordCount.py}

Die Anzahl der Buchstaben beträgt 2252.



\section*{Aufgabe 2}

\subsection*{Pseudo-Code}
\lstinputlisting[style=c,basicstyle=\small\ttfamily]{Code/linearList.c}

\subsection*{Beschreibung}
Füge drei Knoten in den Fibonacci-Heap ein. Der erste Knoten ist hierbei um 1 größer, der zweite um 1 kleiner und der dritte um 2 kleiner als das aktuelle Minimum. Lösche nun den Minimumknoten, aktualisiere ihn und setzte den Wert des Größten Kindes des neuen Minimumknotens auf das aktuelle Minimum -2. Es ergibt sich somit ein neues Minimum, das in die Wurzelliste aufgenommen wird. Dieses wird nun abschließend gelöscht. In jedem Schritt wird so also genau ein Knoten in den Heap eingefügt. Es ergibt sich somit eine vertikale Liste.

%\subsection*{Beispiel}

\pagebreak

\section*{Aufgabe 3}

\subsection*{a)}

\subsubsection*{Hilfsmethode}
\begin{lstlisting}[style=c,basicstyle=\small\ttfamily]
int left(int i) {
	return 2i+1;
}

int right(int i) {
	return  2i+2;
}

int parent(int i) {
	return floor((i-1)/2);
}

// Heap-Eigenschaft herstellen
void heapify(Array b, int i) {
	// kleinstes Element des Asts finden 
	int min = i
	if (left(i) < b.size && b[left(i)].key < b[min].key)
		min = left(i)
	if (right(i) < b.size && b[right(i)].key < b[min].key)
		min = right(i)
		
	// wenn ein kleines Element existiert dann stelle die Heap-Eigenschaft her
	if (min != i) {
		b.swap(i, min)
		// verfahre kaskadenartig weiter
		heapify(b, min)
	}
}

\end{lstlisting}

\subsubsection*{decreaseKey}
\begin{lstlisting}[style=c,basicstyle=\small\ttfamily]
bool decrease(Array b, int i, newKey) {
	// neuer Schlüssel muss kleiner sein als alter
	if (newKey > b[i].key)
		return false;
	
	// Schlüssel setzten
 	b[i].key = newKey;
	
	// Heap-Eigenschaft herstellen
	while (i > 0 && b[i].key < b[parent(i)].key)) {
    		b.swap(i, parent(i));
    		i = parent(i);
	}
	return true;
}
\end{lstlisting}


\pagebreak


\subsubsection*{deleteMin}
\begin{lstlisting}[style=c,basicstyle=\small\ttfamily]
int deleteMin(Array b) {
	if (i<b.size)
		return -1; // Index out of bounds
	min = b[0];
	b.swap(i, -1); // sei -1 der Index des letzten Elements
	b.size -= 1 // verringere die Array Größe um 1

	// Heap-Eigenschaft herstellen
	if ((b.size > 0)
		heapify(b, i)
	return min;	
}
\end{lstlisting}


\subsubsection*{insert}
\begin{lstlisting}[style=c,basicstyle=\small\ttfamily]
void insert(Array b, newKey) {
	int i = b.size
	b.size += 1;
	// setzte b auf den höchst möglichen Wert
	b.key = MAX_INT 
	// Update den Wert und die Heap-Eigenschaft mit decrease
	decrease(b, i, newKey)
}
\end{lstlisting}


\subsection*{b)}
Die Laufzeit für die decreaseKey Operation beträgt $O(Baumtiefe) = O(\log(n))$. Unter der Annahme, dass das Resizen des Arrays in konstanter Zeit realisiert werden kann, beträgt somit die Laufzeit für insert ebenfalls $O(\log(n))$. Ausschlaggebend für die deleteMin Operation ist die heapify Methode, da sich der Rest der Implementierung in konstanter Zeit realisieren lässt. Die Laufzeit für heapify und somit auch für deleteMin beträgt ebenfalls $O(Baumtiefe) = O(\log(n))$.

\subsection*{c)}
Füge alle Elemente unsortiert in ein Array ein. Laufzeit: $O(1)$.\\
Wende nun Radix-Sort auf das Array an, um es zu sortieren. Laufzeit: $O(n)$. (Siehe hierzu VL 11)\\
Die Heap-Eigenschaft ist nun für alle Knoten erfüllt.


\end{document}