\documentclass[a4paper,11pt,twoside]{scrartcl}
\input{../../head/package}
\input{../../head/listing}
\input{../../head/format}
\input{../../head/math}

\title{Datenstrukturen und effiziente Algorithmen\\ Übung 11}
\author{Markus Vieth, David Klopp, Christian Stricker}
\date{\today}



\begin{document}

\maketitle
\cleardoublepage
\pagestyle{myheadings}
\markboth{Markus Vieth,  David Klopp, Christian Stricker}{Markus Vieth, David Klopp, Christian Stricker}


\section*{Aufgabe 1}
\subsection{Mergebale Heap}
\texttt{insert, Min, ExtractMin, Union, Make-Heap}
\paragraph{zusätzlich} \texttt{DecreaseKey, Delete}\\
\begin{tabular}{c|c|c|c|c|c|c|c}
	 &\texttt{Make-Heap}&\texttt{Insert}&\texttt{Min}&\texttt{Extr.Min}&\texttt{Union}&\texttt{Dec.-Key}&\texttt{Del} \\ \hline
	 Fib-Heap&$1$&$1$&$1$&$\log n$&$1$&$1$&$\log n$ \\ \hline
	 Bin-Heap&$1$&$\log n$&$1$&$\log n$&$n$&$\log n$&$\log n$ 
\end{tabular}

Zyklische doppelt verkettete Liste von Wurzelknoten\\
Darunter Bäume
\begin{itemize}
	\item Kinder eines Knoten ebenfalls zylisch doppelt verkettete Liste
	\item Jeder Knoten Pointer zum Vater (außer Wurzel) und zum Kind/ zur Kinderliste
\end{itemize}
keine Sortierung in Wurzelliste/Kindliste\\
Heap hat zudem Attribute \texttt{min} und \texttt{size}
\begin{description}
	\item[$\forall$ Knoten:]  $\#$Kinder(direkt) ''rank''/''degree''
	\item[ ]bool marked (false zu Beginn)
\end{description}
\begin{description}
	\item[insert:] neuer Node in Wurzelliste einfügen, H.min und H.size anpassen $\Rightarrow$ konstant
	\item[Min:] min-pointer zurückgeben $\Rightarrow$ konstant
	\item[Union:] Wurzellisten zusammenführen, Min und Size anpassen $\Rightarrow$ konstant
	\item[Extract-min] $ $\\ \begin{description}
		\item[Für size $< 2$] Min zurückgeben wenn vorhanden, danach leerer Heap
		\item[Für size $\geq 2$] gib min zurück, setze min auf anderen Knoten in Wurzelliste, consolidate, min und size updaten
	\end{description} $\Rightarrow~~\log n$ 
	
	\paragraph{Consolidate}
	\subparagraph{Ziel}
	Nach Consolidierung sollen in der Wurzellsite keine zwei Knoten mit dem selben Rang sein.\\
	Node-Pointer-Array mit Größe $\log(size)$
	\item[decreaseKey] Setze Key auf neuen Wert, wenn Heapeigenschaft verletzt:
	\begin{lstlisting}
		do {
			Nehme x in Wurzellsite auf, entferne x aus der Kindesliste seines Parents
			Wenn x.p nicht makietr war:
				makiere x.p
				break
			sonst x = x.p
			Nehme x in Wurzellsite auf
		}while true
	\end{lstlisting}
	$\Rightarrow$ amort konstant
	\item[Delete] \begin{lstlsiting}
		decreaseKey mit $-\infty$ ($\infty$ bei Maxheap)
		extractMin
	\end{lstlsiting}
	$\Rightarrow~~\log n$ 
\end{description}


\pagebreak

\section*{Aufgabe 3}

\subsection*{a)}

\subsubsection*{Hilfsmethode}
\begin{lstlisting}[style=c,basicstyle=\small\ttfamily]
int left(int i) {
	return 2i+1;
}

int right(int i) {
	return  2i+2;
}

int parent(int i) {
	return floor((i-1)/2);
}

// Heap-Eigenschaft herstellen
void heapify(Array b, int i) {
	// kleinstes Element des Asts finden 
	int min = i
	if (left(i) < b.size && b[left(i)].key < b[min].key)
		min = left(i)
	if (right(i) < b.size && b[right(i)].key < b[min].key)
		min = right(i)
		
	// wenn ein kleines Element existiert dann stelle die Heap-Eigenschaft her
	if (min != i) {
		b.swap(i, min)
		// verfahre kaskadenartig weiter
		heapify(b, min)
	}
}

\end{lstlisting}

\subsubsection*{decreaseKey}
\begin{lstlisting}[style=c,basicstyle=\small\ttfamily]
bool decrease(Array b, int i, newKey) {
	// neuer Schlüssel muss kleiner sein als alter
	if (newKey > b[i].key)
		return false;
	
	// Schlüssel setzten
 	b[i].key = newKey;
	
	// Heap-Eigenschaft herstellen
	while (i > 0 && b[i].key < b[parent(i)].key)) {
    		b.swap(i, parent(i));
    		i = parent(i);
	}
	return true;
}
\end{lstlisting}


\pagebreak


\subsubsection*{deleteMin}
\begin{lstlisting}[style=c,basicstyle=\small\ttfamily]
int deleteMin(Array b) {
	if (i<b.size)
		return -1; // Index out of bounds
	min = b[0];
	b.swap(i, -1); // sei -1 der Index des letzten Elements
	b.size -= 1 // verringere die Array Größe um 1

	// Heap-Eigenschaft herstellen
	if ((b.size > 0)
		heapify(b, i)
	return min;	
}
\end{lstlisting}


\subsubsection*{insert}
\begin{lstlisting}[style=c,basicstyle=\small\ttfamily]
void insert(Array b, newKey) {
	int i = b.size
	b.size += 1;
	// setzte b auf den höchst möglichen Wert
	b.key = MAX_INT 
	// Update den Wert und die Heap-Eigenschaft mit decrease
	decrease(b, i, newKey)
}
\end{lstlisting}


\subsection*{b)}
Die Laufzeit für die decreaseKey Operation beträgt $O(Baumtiefe) = O(\log(n))$. Unter der Annahme, dass das Resizen des Arrays in konstanter Zeit realisiert werden kann, beträgt somit die Laufzeit für insert ebenfalls $O(\log(n))$. Ausschlaggebend für die deleteMin Operation ist die heapify Methode, da sich der Rest der Implementierung in konstanter Zeit realisieren lässt. Die Laufzeit für heapify und somit auch für deleteMin beträgt ebenfalls $O(Baumtiefe) = O(\log(n))$.

\subsection*{c)}
Füge alle Elemente unsortiert in ein Array ein. Laufzeit: $O(1)$.\\
Wende nun Radix-Sort auf das Array an, um es zu sortieren. Laufzeit: $O(n)$. (Siehe hierzu VL 11)\\
Die Heap-Eigenschaft ist nun für alle Knoten erfüllt.

\section*{Zusatz 1}
\subsection*{a)}
\paragraph{Behauptung}
$(E,M) = (\{ a,b,c,d \}, \{ \emptyset,\{ a \},\{ b \},\{ c \}\{ d \}\}  )$ ist ein Matroid.
\paragraph{Beweis}
\subparagraph{zu zeigen: Nicht-Leerheit}
\[ \emptyset\in M=\{  \emptyset,\{ a \},\{ b \},\{ c \}\{ d \}\} \} \]
\subparagraph{zu zeigen: Vererbung}
Die Teilmengen einer einelementigen Menge sind die Menge selbst und die leere Menge. Somit ist offensichtlich, dass auch diese Bedingung erfüllt ist.
\subparagraph{zu zeigen: Austausch}
Sei $X$ eine der einelementigen Mengen aus $M$. Das einzige Element mit geringerer Kardinalität ist die leere Menge.
\[\Rightarrow \exists x\in X\setminus\emptyset=X | \{ x \}\cup\emptyset=X\in M \]
$\Rightarrow$ $(E,M)$ ist ein Matroid.
\subsection*{b)}
\paragraph{Nich-Leerheit}
$M$ muss die leere Menge enthalten $\Rightarrow$ $M':=\{ \emptyset,\{a,b \},\{ c,d \}\}\subseteq M$.
\paragraph{Vererbung}
Sei $\mathcal{P}(X)$ die Potenzmenge der Menge $X$\\
\[ M'\cup\mathcal{P}(\emptyset)\cup\mathcal{P}(\{a,b\})\cup\mathcal{P}(\{c,d\}) = \{ \emptyset,\{a,b \},\{ c,d \},\{ a \},\{ b \},\{ c \},\{ d \} \}=:M''\subseteq M \]
\paragraph{Austausch}
Wie in Teilaufgabe a) erklärt, muss die leere Menge nicht weiter betrachtet werden, da mit dieser lediglich die einelementigen Mengen erzeugt werden können.
\begin{description}
	\item[$A=\{v\},B=\{v,w\}$ mit $v,w\in E$] $B\setminus A = \{w\}, \{w\}\cup A = \{v,w\}$
	\item[$A=\{a\},B=\{c,d\}$] $B\setminus A = \{c,d\} \Rightarrow \{c\}\cup\{a\}=\{a,c\}\in M \veebar \{d\}\cup\{a\}=\{a,d\}\in M$
	\item[$A=\{b\},B=\{c,d\}$] $B\setminus A = \{c,d\} \Rightarrow \{c\}\cup\{b\}=\{b,c\}\in M \veebar \{d\}\cup\{b\}=\{b,d\}\in M$
	\item[$A=\{c\},B=\{a,b\}$] $B\setminus A = \{a,b\} \Rightarrow \{a\}\cup\{c\}=\{a,c\}\in M \veebar \{b\}\cup\{c\}=\{b,c\}\in M$
	\item[$A=\{d\},B=\{a,b\}$] $B\setminus A = \{a,b\} \Rightarrow \{a\}\cup\{d\}=\{a,d\}\in M \veebar \{b\}\cup\{d\}=\{b,d\}\in M$
\end{description}
\[\Rightarrow M=\{ \emptyset,\{a,b \},\{ c,d \},\{ a \},\{ b \},\{ c \},\{ d \},\{a,c\},\{b,d\} \}\veebar M=\{ \emptyset,\{a,b \},\{ c,d \},\{ a \},\{ b \},\{ c \},\{ d \},\{a,d\},\{b,c\} \}\]
$\Rightarrow(E,M)$ ist der kleinste Matroid, welcher den Anforderungen entspricht.
\begin{flushright}
	q.e.d.
\end{flushright}
\pagebreak
\section*{Zusatz 2}
\subsection*{a)}
\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{Images/Matroid}
\caption{graphischer Matroid}
\label{fig:Matroid}
\end{figure}

Die Teilmengen größter Kardinalität sind $M_1:=\{ (a,b),(b,c),(c,d) \},M_2:=\{ (a,b),(b,c),(d,a) \},\\M_3:=\{ (a,b),(c,d),(d,a) \},M_4:=\{ (b,c),(c,d),(d,a) \}$. Es handelt sich dabei um die möglichen Spannbäume des Graphen $G$.
\subsection*{b)}
Es handelt sich um den Algorithmus von Kruskal. Der Algorithmus gibt $B=\{ (a,b),(b,c),(c,d) \}$ aus. Die Abfrage verhindert das Bilden von Zyklen.
\subsection*{c)}
Das Sortieren der Kanten hat im Allgemeinen (also ohne Radix-Sort) eine Laufzeit in $\mathcal{O}(|E| \log |E|)$. Die Schleife läuft über die Menge aller Kanten, also $|E|$ mal. Innerhalb der Schleife gibt es die Abfrage mit der Laufzeit $f(|E|)$ und die Einfüge-Operation, welche mit passender Datenstruktur in konstanter Zeit ausgeführt werden kann. Somit ergibt sich eine Laufzeit in $\mathcal{O}(|E|\log|E|+|E|f(|E|))$.
\subsection*{d)}

\begin{wrapfigure}{l}{0.3\linewidth}
	\centering
	\includegraphics[width=0.5\linewidth]{Images/Beispiel}
	\caption{Sei n eine beliebigen Länge}
	\label{fig:Beispiel}
\end{wrapfigure}
Nein, der Algorithmus ist nicht eindeutig. Man denke sich einen dreieckigen Graphen mit den Kanten $E:=\{ (a,b),(b,c),(c,a) \}$ welche ein einheitliches Kantengewicht aufweisen. Das Ergebnis ist nun vom Sortierverfahren abhängig. So liefern allein stabile und instabile Algorithmen verschiedene Ergebnisse. Mögliche Lösungen wären $L_1:=\{ (a,b),(b,c) \},L_2:=\{ (a,b),(c,a)\},L_3:=\{ (b,c),(c,d) \}$
\end{document}