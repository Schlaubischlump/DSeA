
\documentclass[a4paper,11pt,twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{ngerman, eucal, mathrsfs, amsfonts, bbm, amsmath, amssymb, stmaryrd,graphicx, array, geometry, listings, color}
\usepackage{graphicx}
\geometry{left=25mm, right=15mm, bottom=25mm}
\setlength{\parindent}{0em} 
\setlength{\headheight}{0em} 
\title{Theoretische Grundlagen der Informatik II\\ Blatt 5}
\author{Markus Vieth, David Klopp, Christian Stricker}
\date{\today}
\definecolor{middlegray}{rgb}{0.5,0.5,0.5}
\definecolor{lightgray}{rgb}{0.8,0.8,0.8}
\definecolor{orange}{rgb}{0.8,0.3,0.3}
\definecolor{yac}{rgb}{0.6,0.6,0.1}
\definecolor{green}{rgb}{0,.5,0}
\lstset{
	basicstyle=\scriptsize\ttfamily,
	keywordstyle=\bfseries\ttfamily\color{blue},
	stringstyle=\color{orange}\ttfamily,
	commentstyle=\color{green}\ttfamily,
	emph={@Override}, 
	emphstyle=\color{green}\texttt,
	emph={[2]Node,T,Comparable,AbstractNode,System, Thread,Random, Tree, Integer, Math, String, InterruptedException},
	emphstyle={[2]\color{yac}\texttt},
	showstringspaces=false,
	flexiblecolumns=false,
	tabsize=2,
	numbers=left,
	numberstyle=\tiny,
	numberblanklines=false,
	stepnumber=1,
	numbersep=10pt,
	xleftmargin=15pt
}
\begin{document}
\maketitle
\cleardoublepage
\pagestyle{myheadings}
\markboth{Markus Vieth,  David Klopp, Christian Stricker}{Markus Vieth, David Klopp, Christian Stricker}
\section*{Aufgabe 1}
\subsection*{a-d)}
\subsubsection*{Node.java}
\lstinputlisting[language=JAVA]{NR_1_src/Node.java}
\subsubsection*{Tree.java}
\lstinputlisting[language=JAVA]{NR_1_src/Tree.java}
\subsubsection*{zu d)}
\[k = 2 \text{ : durchschnittliche Tiefe }= 13\]
\[k = 3 \text{ : durchschnittliche Tiefe }= 21\]
\[k = 4 \text{ : durchschnittliche Tiefe }= 33\]
\[k = 5 \text{ : durchschnittliche Tiefe }= 40\]
\[k = 6 \text{ : durchschnittliche Tiefe }= 50\]
Da beim verzehnfachen der Elemente sich die Tiefe konstant um ca. 9 vergrößert, wächst die Baumtiefe asymptotisch in $\log n$ 
\subsection*{e)}
\subsubsection*{Szenario 1}
Es sollen Daten mit nicht fortlaufendem Wert/Schlüssel gefunden werden.\\
\paragraph*{Beispiel} Das finden eines Wortes in einem Wörterbuch. Ein Array bräuchte hier im Schnitt $\frac{n}{2}$ Schritte, ein Binärer Suchbaum $\log_2 n$ und ist somit schneller.
\subsection*{Szenario 2}
Es sollen Duplikate gefunden werden.\\
\paragraph*{Beispiel} 2 Datenbanken sollen zusammen gelegt werden und Duplikate sollen gelöscht werden. Ein Array bräuchte hier im Worst-Case $\sum_{i=1}^n i \in O(n^2)$ Schritte, ein Binärer Suchbaum $O(n \log n)\ni\sum_{i=1}^n\log_2 i \leq \sum_{i=1}^n\log_2 n = n \log_2 n$ und ist somit schneller.
\pagebreak
\section*{Aufgabe 2}
\underline{Anmerkung: } Pfeile ohne Endknoten deuten einen beliebig großen Teilbaum an. Teilbäume bei Knoten D wurden vergessen einzuzeichnen, können aber natürlich auch existieren.
\subsection*{a)} Ersetze z mit seinem rechten Kind. Da z kein linkes Kind besitzt, ist das Löschen von z fertig.\\
\includegraphics*[scale=0.2]{Images/A.png}
\subsection*{b)}Ersetze z mit dem linken Kind. Da z kein rechtes Kind besitzt, ist das Löschen von z fertig.\\
\includegraphics*[scale=0.2]{Images/B.png}
\subsection*{c)} Hänge den linken Teilbaum von z an y und tausche y mit z. \\
\includegraphics*[scale=0.2]{Images/C.png}
\subsection*{d)} Suche das kleinste Element y vom rechten Teilbaum von z. Setze y als Parent vom rechten Kind von z und das rechte Kind von z als rechtes Kind von y. Danach ersetze z mit y und setze das linke Kind von z an die Stelle vom linken Kind von y. Das Löschen ist fertig. \\
\includegraphics*[scale=0.2]{Images/D_step_1.png} \\
\includegraphics*[scale=0.2]{Images/D_step_2.png} \\
\includegraphics*[scale=0.2]{Images/D_step_3.png}
\end{document}